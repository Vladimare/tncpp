#include "crypto.h"
#include "corelib.h"

#include <string.h>

//начальный блок для шифрования
unsigned char const crypto_start_chain[16] = 
{0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF};

//таблица обратных перестановок для алгоритма AES. Посчитана заранее и размещена в ПЗУ для экономии ОЗУ
const unsigned char sBoxInv[256]=
{
  0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,
  0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
  0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,
  0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
  0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
  0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
  0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,
  0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
  0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,
  0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
  0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,
  0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
  0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,
  0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
  0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
  0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
  0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,
  0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
  0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,
  0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
  0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
  0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
  0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
  0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
  0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
  0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
  0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,
  0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
  0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
  0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
  0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
  0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
};

//расширенный ключ, полученный из 16 байтного ключа стандартным способом, принятым в AES
//  готовится отдельно и подставляется в программу
const unsigned char ExKey[EXPANDED_KEY_SIZE] =
{
  0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x63,0x61,0x60,0x67,0x66,0x67,0x67,0x6F,0x6F,0x67,0x67,0x6F,0x6F,0x67,0x67,0x6F,
  0xE4,0xE4,0xC8,0xCF,0x82,0x83,0xAF,0xA0,0xED,0xE4,0xC8,0xCF,0x82,0x83,0xAF,0xA0,
  0x0C,0x9D,0x28,0xDC,0x8E,0x1E,0x87,0x7C,0x63,0xFA,0x4F,0xB3,0xE1,0x79,0xE0,0x13,
  0xB2,0x7C,0x55,0x24,0x3C,0x62,0xD2,0x58,0x5F,0x98,0x9D,0xEB,0xBE,0xE1,0x7D,0xF8,
  0x5A,0x83,0x14,0x8A,0x66,0xE1,0xC6,0xD2,0x39,0x79,0x5B,0x39,0x87,0x98,0x26,0xC1,
  0x3C,0x74,0x6C,0x9D,0x5A,0x95,0xAA,0x4F,0x63,0xEC,0xF1,0x76,0xE4,0x74,0xD7,0xB7,
  0xEE,0x7A,0xC5,0xF4,0xB4,0xEF,0x6F,0xBB,0xD7,0x03,0x9E,0xCD,0x33,0x77,0x49,0x7A,
  0x9B,0x41,0x1F,0x37,0x2F,0xAE,0x70,0x8C,0xF8,0xAD,0xEE,0x41,0xCB,0xDA,0xA7,0x3B,
  0xD7,0x1D,0xFD,0x28,0xF8,0xB3,0x8D,0xA4,0x00,0x1E,0x63,0xE5,0xCB,0xC4,0xC4,0xDE,
  0xFD,0x01,0xE0,0x37,0x05,0xB2,0x6D,0x93,0x05,0xAC,0x0E,0x76,0xCE,0x68,0xCA,0xA8
};

//операция XOR над массивом байт
//  bytes1 - указатель на первыйы массив байт
//  bytes2 - указатель на второй массив байт
//  count - количество байт для обработки, кратно 4
void cr_XORbytes(unsigned char* bytes1, const unsigned char* bytes2, unsigned char count)
{
  do
  {
    *bytes1 ^= *bytes2;
    bytes1++;
    bytes2++;
  }while(--count);
}

//обратный сдвиг колонок
//  state - указатель на "состояние"
void cr_invShiftRows(unsigned char* state)
{
  unsigned char temp;
  // Note: State is arranged column by column.
  // Cycle second row right one time.
  temp = state[1 + 3 * 4];
  state[1 + 3 * 4] = state[1 + 2 * 4];
  state[1 + 2 * 4] = state[1 + 1 * 4];
  state[1 + 1 * 4] = state[1 + 0 * 4];
  state[1 + 0 * 4] = temp;
  // Cycle third row right two times.
  temp = state[2 + 0 * 4];
  state[2 + 0 * 4] = state[2 + 2 * 4];
  state[2 + 2 * 4] = temp;
  temp = state[2 + 1 * 4];
  state[2 + 1 * 4] = state[2 + 3 * 4];
  state[2 + 3 * 4] = temp;
  // Cycle fourth row right three times, ie. left once.
  temp = state[3 + 0 * 4];
  state[3 + 0 * 4] = state[3 + 1 * 4];
  state[3 + 1 * 4] = state[3 + 2 * 4];
  state[3 + 2 * 4] = state[3 + 3 * 4];
  state[3 + 3 * 4] = temp;
}

//обратная подстановка байт и XOR с ключом
//  bytes - указатель на обрабатываемый массив
//  key - ключ
//  count - количество байт для работы
void cr_invSubBytesAndXOR(unsigned char* bytes, const unsigned char* key, unsigned char count)
{
  do
  {
    *bytes = sBoxInv[*bytes] ^ *key;  //inverse substitute every byte in state and add key
    bytes++;
    key++;
  }while(--count);
}

//обратное перемешивание колонки
//  column - указатель на колонку
void cr_invMixColumn(unsigned char* column)
{
  unsigned char r0, r1, r2, r3;
  r0 = column[1] ^ column[2] ^ column[3];
  r1 = column[0] ^ column[2] ^ column[3];
  r2 = column[0] ^ column[1] ^ column[3];
  r3 = column[0] ^ column[1] ^ column[2];
  column[0] = (column[0] << 1) ^ (column[0] & 0x80 ? BPOLY : 0);
  column[1] = (column[1] << 1) ^ (column[1] & 0x80 ? BPOLY : 0);
  column[2] = (column[2] << 1) ^ (column[2] & 0x80 ? BPOLY : 0);
  column[3] = (column[3] << 1) ^ (column[3] & 0x80 ? BPOLY : 0);
  r0 ^= column[0] ^ column[1];
  r1 ^= column[1] ^ column[2];
  r2 ^= column[2] ^ column[3];
  r3 ^= column[0] ^ column[3];
  column[0] = (column[0] << 1) ^ (column[0] & 0x80 ? BPOLY : 0);
  column[1] = (column[1] << 1) ^ (column[1] & 0x80 ? BPOLY : 0);
  column[2] = (column[2] << 1) ^ (column[2] & 0x80 ? BPOLY : 0);
  column[3] = (column[3] << 1) ^ (column[3] & 0x80 ? BPOLY : 0);
  r0 ^= column[0] ^ column[2];
  r1 ^= column[1] ^ column[3];
  r2 ^= column[0] ^ column[2];
  r3 ^= column[1] ^ column[3];
  column[0] = (column[0] << 1) ^ (column[0] & 0x80 ? BPOLY : 0);
  column[1] = (column[1] << 1) ^ (column[1] & 0x80 ? BPOLY : 0);
  column[2] = (column[2] << 1) ^ (column[2] & 0x80 ? BPOLY : 0);
  column[3] = (column[3] << 1) ^ (column[3] & 0x80 ? BPOLY : 0);
  column[0] ^= column[1] ^ column[2] ^ column[3];
  r0 ^= column[0];
  r1 ^= column[0];
  r2 ^= column[0];
  r3 ^= column[0];
  column[0] = r0;
  column[1] = r1;
  column[2] = r2;
  column[3] = r3;
 }

//обратное перемешивание колонок
//  state - указатель на "состояние"
void cr_invMixColumns(unsigned char* state)
{
  cr_invMixColumn(state + 0 * 4);
  cr_invMixColumn(state + 1 * 4);
  cr_invMixColumn(state + 2 * 4);
  cr_invMixColumn(state + 3 * 4);
}

//кодирование блока
//  block - указатель на блок данных
//  expandedKey - указатель на расширенный ключ
void cr_inv_crypt(unsigned char* block, const unsigned char* expandedKey)
{
  unsigned char round = ROUNDS - 1;
  expandedKey += BLOCKSIZE * ROUNDS;
  cr_XORbytes(block, expandedKey, 16);
  expandedKey -= BLOCKSIZE;
  do
  {
    cr_invShiftRows(block);
    cr_invSubBytesAndXOR(block, expandedKey, 16);
    expandedKey -= BLOCKSIZE;
    cr_invMixColumns(block);
  }while(--round);
  cr_invShiftRows(block);
  cr_invSubBytesAndXOR(block, expandedKey, 16);
}

//расшифровка блока с учетом chainBlock, который остается от обработки предыдущего блока
//  buffer - указатель на блок
//  chainBlock - указатель на сhainBlock
void cr_aes_decrypt(unsigned char* buffer, unsigned char* chainBlock)
{
  unsigned char temp[BLOCKSIZE];
  memcpy(temp, buffer, BLOCKSIZE);
  cr_inv_crypt(buffer, ExKey);
  cr_XORbytes(buffer, chainBlock, BLOCKSIZE);
  memcpy(chainBlock, temp, BLOCKSIZE);
}
//расшифровка блока сектора (внутри блока находится и контрольная сумма)
//  размер сектора 1024 байт
//  blk - указатель на буфер с шифрованными данными
//  возвращает контрольную сумму расшифрованного сектора
unsigned long cr_decrypt_sector(unsigned char* blk)
{
  static volatile unsigned long j = 0;
  unsigned char* dst= 0;
  unsigned long crc = 0;
  unsigned char chain[16];

  memcpy(chain, crypto_start_chain, 16);

  dst = blk;
  for(j = 0; j < (1024 + 16) / 16; j++)
  {
    cr_aes_decrypt(dst, chain);
    dst += 16;
  }
  crc = ntohl(*((unsigned long*)blk));//первые 16 байт это заголовок с контрольной суммой и со случайными данными
  dst = blk + 16;
  for(j = 0; j < 1024; j++)           //сдвиг данных на место заголовка
  {
    *blk++ = *dst++;
  }
  return crc;
}
