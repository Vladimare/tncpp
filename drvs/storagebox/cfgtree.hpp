#ifndef __CFGTREE__HPP__
#define __CFGTREE__HPP__

#include "extstorage.hpp"

                                      /* флаг указывающий на то что блок      *
                                       * конфигурационных данных дублируется  *
                                       * в ОЗУ                                */
#define   CFG_CACHED (0x80)

                                      /* структура описывающая 1 блок данных  *
                                       * конфигурации при создании дерева     */
typedef struct tagCFGENTRY
{
  unsigned char blk_number;
  unsigned char blk_flags;            /* 7 бит - признак дублирования в ОЗУ   */
                                      /* 1 - дублируется, 0 - нет             */
                                      /* 2 мл бита - уровень                  */
  unsigned short blk_sz;
} CFGENTRY;


/* класс для хранения и доступа к настройкам хранящихся в структурированном виде 
например вот так
1. "ID"
1.1 "USER"
1.2 "PASS"
1.2.1 "MIN LEN"
1.2.2 "TRY COUNT"
1.3 "CHANNEL 2 HOST"
1.3.1 "RF"
1.3.1.1 "BASE FREQ"
1.3.1.2 "BAND WITDH"
1.3.1.3 "POWER"
1.3.1.4 "DURATION"
1.3.1.5 "MIN RSSI"
2. "41"
3. "PHONE NUM"

блок конфигурации может содержать произвольный набор данных фиксированной длинны,
длинна блока данных задается при инициализации и индивидуальна для каждого блока
блоки адресуются с помощью индекса в виде ХХ.ХХ.ХХ.ХХ, индекс указывается как 
unsigned long, старшие уровни в младших байтах. 
Например индекс конфигурации "RF" 0x00010301

для блоков конфигурации требующих частое обращение можно указать необходимость 
дублировать данные в ОЗУ. Алгоритм работы с буфером - сквозная запись, чтение 
всегда из буфера, запись всегда происходит одновременно в буфер и во внешний 
носитель. В ОЗУ дублируются только данные, без заголовка и контрольной суммы

запись блока во внешней памяти имеет следующую структуру
[0] - номер блока
[1] - мл. байт длинны блока (N)
 
[2].0:4 - ст. часть длинны блока данных
[2].5:6 - уровень блока.
[2].8 - признак дублирования в ОЗУ

[3 + N] - блок данных, может отсутствовать.

CRC16 вычисляется для байт с 0 до 3 + N
[N + 3] - CRC16 мл. байт
[N + 3 + 1] - CRC16 ст. байт

*/
class cfgtree
{
public:
  cfgtree(const SS_INFO& ssi, extstorage* estrg);
  ~cfgtree();

                                      /* инициализация дерева конфигурации   */
  int init(CFGENTRY* headers, int size);

                                      /* чтение блока конфигурации           */
  int read(unsigned long index, unsigned char* buf, int bufsz);

                                      /* запись блока конфигурации           */
  int write(unsigned long index, unsigned char* buf, int bufsz);
private:

  SS_INFO     layout;                 /* разметка области внешнего носителя  * 
                                       * используемая для хранения дерева конф*/

  extstorage* carrier;                /* интерфейс для доступа к внешнему    */
                                      /* носителю данных                     */

                                      /* внутренняя структура описывающая 1  *
                                       * блок данных конфигурации            */
  typedef struct tagCFGHDR
  {
    unsigned char number;             /* номер блока на указанном уровне     */
    unsigned char lev;                /* уровень вложенности (1 - 4)         */
    unsigned short size;              /* размер блока данных                 */

    unsigned char * cache;            /* указатель на дубль блока данных     */
                                      /* он же признак использования дублир. */

    unsigned long lookup;             /* смещение блока данных во внешнем    *
                                       * носителе, указывается от начала     *
                                       * носителя, а не дерева               */
  } CFGHDR;

  CFGHDR* bHeaders;                   /* таблица заголовков блоков конфигурац.*/
  int bCount;                         /* количество записей в дереве конфиг. */
  unsigned char* bufInt;              /* внутренний буфер для обмена с данными*/
                                      /* с венешним носителем                */

  int index2num(unsigned long index); /* поиск номера блока по индексу       */
  int packHeadr(int num);             /* формирование заголовка, для записи  */
                                      /* во внешний носитель                 */
};

#endif //__CFGTREE__HPP__
